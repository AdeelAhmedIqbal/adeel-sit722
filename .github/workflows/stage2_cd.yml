name: Stage 2 CD - Deploy to Staging, Test, Destroy, then deploy to Production

on:
  workflow_dispatch:
  pull_request:
    branches: ["testing"]
  push:
    branches: ["main"]

jobs:
  deploy_staging:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/testing'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use aks-set-context for kubectl
      - name: Set Kubernetes context (AKS)
        uses: azure/aks-set-context@v3
        with:
          resource-group: deakinuni
          cluster-name: adeelaks

      - name: Create Staging Namespace
        run: kubectl create namespace staging || true

      - name: Deploy Staging Infrastructure
        run: |
          kubectl apply -n staging -f k8s/configmaps.yaml
          kubectl apply -n staging -f k8s/secrets.yaml
          kubectl apply -n staging -f k8s/product-db.yaml
          kubectl apply -n staging -f k8s/order-db.yaml
          kubectl apply -n staging -f k8s/customer-db.yaml

      - name: Deploy Staging Services
        run: |
          kubectl apply -n staging -f k8s/product-service.yaml
          kubectl apply -n staging -f k8s/order-service.yaml
          kubectl apply -n staging -f k8s/customer-service.yaml
          kubectl apply -n staging -f k8s/frontend.yaml

      
      - name: Wait for LoadBalancer IPs (product, order, and customer)
        id: ips
        run: |
          echo "Waiting for product/order/customer LB IPs..."
          success=false
          for i in {1..60}; do
            PRODUCT_IP=$(kubectl get svc product-service -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            ORDER_IP=$(kubectl get svc order-service   -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            CUSTOMER_IP=$(kubectl get svc customer-service -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            
            if [[ -n "$PRODUCT_IP" && -n "$ORDER_IP" && -n "$CUSTOMER_IP" ]]; then
              echo "product_ip=$PRODUCT_IP" >> $GITHUB_OUTPUT
              echo "order_ip=$ORDER_IP"     >> $GITHUB_OUTPUT
              echo "customer_ip=$CUSTOMER_IP" >> $GITHUB_OUTPUT
              echo "Product: $PRODUCT_IP, Order: $ORDER_IP, Customer: $CUSTOMER_IP"
              success=true
              break
            fi
            echo "Waiting for services... attempt $i/60"
            sleep 5
          done
          
          if [[ "$success" != "true" ]]; then
            echo "IPs not ready after timeout"
            exit 1
          fi

      # --- Inject backend IPs into the frontend bundle, rebuild & push, redeploy ---
      - name: Inject Backend IPs into Frontend main.js
        run: |
          echo "Injecting IPs into frontend/main.js"
          sed -i "s|_PRODUCT_API_URL_|http://${{ steps.ips.outputs.product_ip }}|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://${{ steps.ips.outputs.order_ip }}|g"     frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|http://${{ steps.ips.outputs.customer_ip }}|g" frontend/main.js
          echo "--- Modified main.js ---"
          cat frontend/main.js
          echo "------------------------"

      - name: ACR Login
        run: az acr login --name ${{ secrets.AZURE_CONTAINER_REGISTRY }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest ./frontend/
          docker push ${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest

      - name: Rollout updated Frontend in Staging
        run: |
          kubectl set image deployment/frontend-w08e1 frontend=${{ secrets.AZURE_CONTAINER_REGISTRY }}/frontend:latest -n staging
          kubectl rollout status deployment/frontend-w08e1 -n staging --timeout=180s

      # Optional smoke test & teardown
      # - name: Acceptance Test (Smoke)
      #   run: |
      #     FRONTEND_IP=$(kubectl get svc frontend -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
      #     curl -f "http://${FRONTEND_IP}/" >/dev/null

      # - name: Destroy Staging
      #   if: always()
      #   run: kubectl delete namespace staging

  deploy_production:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Kubernetes context (AKS)
        uses: azure/aks-set-context@v3
        with:
          resource-group: deakinuni
          cluster-name: adeelaks

      - name: Deploy to Production (Permanent Namespace)
        run: |
          kubectl create namespace production || true
          kubectl apply -n production -f k8s/configmaps.yaml
          kubectl apply -n production -f k8s/secrets.yaml
          kubectl apply -n production -f k8s/product-db.yaml
          kubectl apply -n production -f k8s/order-db.yaml
          kubectl apply -n production -f k8s/product-service.yaml
          kubectl apply -n production -f k8s/order-service.yaml
          kubectl apply -n production -f k8s/frontend.yaml
